# -*- coding: utf-8 -*-
"""TalentScout.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ma1t2zPQdhoOIPhqC2-vJVT31lDyu4ea
"""

!pip install gradio transformers torch

from transformers import GPT2Tokenizer, GPT2LMHeadModel
import torch
import gradio as gr
import re
from sentence_transformers import SentenceTransformer, util

# Load GPT-2
model_name = "gpt2"
tokenizer = GPT2Tokenizer.from_pretrained(model_name)
model = GPT2LMHeadModel.from_pretrained(model_name)
model.eval()

# Load embedding model for better scoring
embedder = SentenceTransformer('all-MiniLM-L6-v2')

# Skill-based questions
skill_questions = {
    "Java": [
        ("What is the difference between HashMap and Hashtable?", "HashMap is not synchronized and allows null keys, whereas Hashtable is synchronized and does not allow null keys."),
        ("Explain OOP principles in Java.", "OOP principles include Encapsulation, Inheritance, Polymorphism, and Abstraction."),
        ("Write a Java function to reverse a string.", "Use StringBuilder reverse() or iterate from end to start.")
    ],
    "Python": [
        ("What is a Python decorator?", "A decorator is a function that takes another function and extends its behavior without modifying it."),
        ("Explain the difference between list and tuple.", "List is mutable, tuple is immutable."),
        ("Write a Python function to check if a number is prime.", "Loop through numbers and check divisibility.")
    ]
}

# Conversation state
conversation_state = {
    "step": 0,
    "name": "",
    "email": "",
    "contact": "",
    "experience": "",
    "position": "",
    "location": "",
    "skill": "",
    "library": "",
    "answers": [],
    "question_index": 0
}

# Validation Functions
def validate_name(name):
    return bool(re.match(r"^[A-Za-z ]{2,}$", name))

def validate_email(email):
    return bool(re.match(r"^[\w\.-]+@[\w\.-]+\.\w+$", email))

def validate_contact(contact):
    return bool(re.match(r"^\d{10}$", contact))

# Scoring using embeddings
def calculate_score(answer, reference):
    answer_emb = embedder.encode(answer, convert_to_tensor=True)
    ref_emb = embedder.encode(reference, convert_to_tensor=True)
    similarity = util.cos_sim(answer_emb, ref_emb).item()
    return round(similarity * 100, 2)
    # Compute semantic similarity
    candidate_embedding = model.encode(answer)
    score = util.cos_sim(model.encode(" ".join(correct_keywords)), candidate_embedding).item()

    # Normalize to 0-10 instead of 0-100
    normalized_score = round(score * 10, 1)  # Scale and round
    return max(0, min(normalized_score, 10))  # Ensure score between 0 and 10


# Chatbot logic
def chatbot_response(message, history):
    step = conversation_state["step"]

    # Step 0: Greeting
    if step == 0:
        conversation_state["step"] = 1
        return "ðŸ‘‹ Hello! I'm TalentScout, your AI hiring assistant. Let's begin!\nWhat's your full name?"

    # Step 1: Validate Name
    if step == 1:
        if not validate_name(message):
            return "Please enter a valid name (only alphabets, at least 2 characters)."
        conversation_state["name"] = message
        conversation_state["step"] = 2
        return f"Nice to meet you, {message}! Please provide your Email address."

    # Step 2: Validate Email
    if step == 2:
        if not validate_email(message):
            return "That doesn't look like a valid email. Please enter again."
        conversation_state["email"] = message
        conversation_state["step"] = 3
        return "Enter your Primary Contact number (10 digits):"

    # Step 3: Validate Contact
    if step == 3:
        if not validate_contact(message):
            return "Invalid phone number. Please enter a 10-digit number."
        conversation_state["contact"] = message
        conversation_state["step"] = 4
        return "How many years of experience do you have?"

    # Step 4: Experience
    if step == 4:
        conversation_state["experience"] = message
        conversation_state["step"] = 5
        return "What position are you looking for? (Options: Software Developer, AI/ML Developer, Full Stack Developer)"

    # Step 5: Position
    if step == 5:
        conversation_state["position"] = message
        conversation_state["step"] = 6
        return "Current Location (City):"

    # Step 6: Location
    if step == 6:
        conversation_state["location"] = message
        conversation_state["step"] = 7
        return "What is your primary skill? (Java or Python)"

    # Step 7: Skill
    if step == 7:
        skill = message.strip().capitalize()
        if skill not in skill_questions:
            return "Please choose either Java or Python."
        conversation_state["skill"] = skill
        conversation_state["step"] = 8
        return f"Great! Do you have experience with any specific libraries or frameworks in {skill}? (If none, type 'No')"

    # Step 8: Libraries
    if step == 8:
        conversation_state["library"] = message
        conversation_state["step"] = 9
        return f"Awesome! Let's test your {conversation_state['skill']} skills.\nHere's your first question:\n\n{skill_questions[conversation_state['skill']][0][0]}"

    # Step 9: Ask Questions
    if step == 9:
        conversation_state["answers"].append(message)
        conversation_state["question_index"] += 1
        if conversation_state["question_index"] < len(skill_questions[conversation_state["skill"]]):
            return f"Next question:\n\n{skill_questions[conversation_state['skill']][conversation_state['question_index']][0]}"
        else:
            conversation_state["step"] = 10
            return "Thanks for answering all questions! Type 'Yes' to see your result."

    # Step 10: Evaluate
    if step == 10 and message.lower() == "yes":
        skill = conversation_state["skill"]
        answers = conversation_state["answers"]
        total_score = 0
        feedback = []

        for i, (question, ref) in enumerate(skill_questions[skill]):
            score = calculate_score(answers[i], ref)
            total_score += score
            feedback.append(f"Q{i+1}: {score}/100")

        avg_score = total_score / len(answers)
        result = "âœ… Shortlist" if avg_score >= 60 else "âŒ Reject"
        interpretation = "Excellent" if avg_score >= 80 else "Good" if avg_score >= 60 else "Needs Improvement"

        return f"Your Results:\n" + "\n".join(feedback) + f"\n\nAverage Score: {avg_score:.2f} ({interpretation})\nRecommendation: {result}"

    return "Please follow the flow."

# Gradio Chat UI
with gr.Blocks() as demo:
    chatbot = gr.Chatbot(value=[("Hi! I'm TalentScout, your hiring assistant. Let's get started!", None)])
    msg = gr.Textbox(placeholder="Type your response here...")
    clear = gr.Button("Clear")

    def respond(message, chat_history):
        bot_message = chatbot_response(message, chat_history)
        chat_history.append((message, bot_message))
        return "", chat_history

    msg.submit(respond, [msg, chatbot], [msg, chatbot])
    clear.click(lambda: [("Hi! I'm TalentScout, your hiring assistant. Let's get started!", None)], None, chatbot, queue=False)

demo.launch()